/**
 * Tests for analyze_project merge/augment functionality.
 *
 * Covers:
 * - parseProjectMdSections: Parsing existing project.md into sections
 * - classifySection: Section classification (auto-update, preserve, static)
 * - mergeAutoUpdateSection: Auto-update section merging with change detection
 * - mergeProjectMd: Full merge orchestration
 * - formatChangeLog: Change log generation
 * - readExistingProjectMd: File reading (integration)
 * - analyzeProject: End-to-end merge path (integration)
 *
 * @module __tests__/tools/analyze-project-merge
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { join } from 'path';
import { mkdtemp, mkdir, writeFile, rm } from 'fs/promises';
import { tmpdir } from 'os';
import type { ParsedSection, MergeChange, ProjectAnalysis } from '../../types/index.js';
import {
  parseProjectMdSections,
  classifySection,
  mergeAutoUpdateSection,
  mergeProjectMd,
  formatChangeLog,
  readExistingProjectMd,
  analyzeProject,
  AUTO_UPDATE_SECTIONS,
  STATIC_SECTIONS,
  generateFreshSection,
} from '../../tools/analyze-project.js';

// ============================================================================
// Test Fixtures
// ============================================================================

/** A minimal project.md with all standard sections */
const FIXTURE_FULL_PROJECT_MD = `# Generated Project Configuration

> **Auto-generated by \`analyze_project\`**
> **Project:** my-app
> **Type:** library

Save this content to \`.clinerules/project.md\` in your project root,
then review and adjust the values as needed.

---

## ðŸš¨ MANDATORY: Load CodeOps Rules Before Any Work

**Before ANY planning or implementation, the AI agent MUST load these rules
using the codeops-mcp tools:**

1. \`get_rule("agents")\` â€” Load agent behavior rules **(REQUIRED FIRST)**
2. \`get_rule("code")\` â€” Load coding standards
3. \`get_rule("testing")\` â€” Load testing workflows
4. \`get_rule("git-commands")\` â€” Load git commit protocols

These rules are **mandatory** and must be consulted before every task.
**Do NOT skip this step. Do NOT proceed without reading these documents.**

---

## Project Overview

- **Name:** my-app
- **Description:** [TODO: Add project description]
- **Type:** library

## Toolchain

- **Language(s):** TypeScript
- **Framework(s):** MCP SDK
- **Package Manager:** yarn
- **Test Framework:** Vitest

**Manifest files found:** package.json, tsconfig.json

## Commands

All commands assume execution from the project root. Prefix all shell commands with \`clear &&\`.

### Build

\`\`\`bash
clear && yarn build
\`\`\`

### Test

\`\`\`bash
# Run all tests
clear && yarn test
\`\`\`

### Verify (before commit)

\`\`\`bash
# Full verification â€” run this before any git commit
clear && yarn build && yarn test
\`\`\`

## Project Structure

### Type: Single repository

### Directory Layout

\`\`\`
src/
docs/
\`\`\`

## Coding Conventions

### Naming

- **Files:** kebab-case
- **Components/Classes:** PascalCase
- **Functions/Methods:** camelCase
- **Constants:** UPPER_SNAKE_CASE

## Git & Commit Conventions

### Commit Scope

\`\`\`
# Use module/feature as scope:
# feat(module): description
\`\`\`

### Branch Strategy

- **Main branch:** \`main\`
- **Feature branches:** \`feature/[name]\`

## Special Rules (Project-Specific)

\`\`\`
No special rules â€” this is an MCP server project.
\`\`\`

## Cross-References

The generic rule files that read this \`project.md\`:

- **make_plan.md** â€” Uses verify command, file paths, commit scope
- **code.md** â€” Uses language conventions, architecture rules
- **testing.md** â€” Uses test commands, test locations, test framework
- **git-commands.md** â€” Uses commit scope, verify command
- **agents.md** â€” Uses shell commands, verify command
- **plans.md** â€” Uses task file path patterns`;

/** A project.md with user-customized description */
const FIXTURE_WITH_CUSTOM_DESCRIPTION = FIXTURE_FULL_PROJECT_MD.replace(
  '- **Description:** [TODO: Add project description]',
  '- **Description:** A powerful MCP server for coding standards',
);

/** A project.md with a custom user-added section */
const FIXTURE_WITH_CUSTOM_SECTION = FIXTURE_FULL_PROJECT_MD + `

## My Custom Section

This is a section the user added manually.
It should be preserved during merge.`;

/** Minimal project.md with just a preamble and one section */
const FIXTURE_MINIMAL = `# My Project

Some intro text.

## Toolchain

- **Language(s):** Python
- **Package Manager:** pip`;

/** A sample ProjectAnalysis matching what scanProject would return */
const SAMPLE_ANALYSIS: ProjectAnalysis = {
  name: 'my-app',
  type: 'library',
  languages: ['TypeScript'],
  frameworks: ['MCP SDK'],
  packageManager: 'yarn',
  testFramework: 'Vitest',
  buildCommand: 'clear && yarn build',
  testCommand: 'clear && yarn test',
  verifyCommand: 'clear && yarn build && yarn test',
  isMonorepo: false,
  structure: ['src', 'docs'],
  manifestFiles: ['package.json', 'tsconfig.json'],
};

/** A modified analysis (simulating a toolchain change) */
const CHANGED_ANALYSIS: ProjectAnalysis = {
  ...SAMPLE_ANALYSIS,
  frameworks: ['MCP SDK', 'ESLint'],
  testFramework: 'Jest',
};

// ============================================================================
// parseProjectMdSections Tests
// ============================================================================

describe('parseProjectMdSections', () => {
  it('should parse a full project.md into sections', () => {
    const sections = parseProjectMdSections(FIXTURE_FULL_PROJECT_MD);

    // Should have preamble + multiple ## sections
    expect(sections.length).toBeGreaterThan(5);

    // First section should be preamble (no header)
    expect(sections[0].header).toBe('');
    expect(sections[0].level).toBe(0);
    expect(sections[0].content).toContain('# Generated Project Configuration');
  });

  it('should correctly identify all ## headers', () => {
    const sections = parseProjectMdSections(FIXTURE_FULL_PROJECT_MD);
    const headers = sections.filter((s) => s.level === 2).map((s) => s.header);

    expect(headers).toContain('## ðŸš¨ MANDATORY: Load CodeOps Rules Before Any Work');
    expect(headers).toContain('## Project Overview');
    expect(headers).toContain('## Toolchain');
    expect(headers).toContain('## Commands');
    expect(headers).toContain('## Project Structure');
    expect(headers).toContain('## Coding Conventions');
    expect(headers).toContain('## Git & Commit Conventions');
    expect(headers).toContain('## Special Rules (Project-Specific)');
    expect(headers).toContain('## Cross-References');
  });

  it('should keep ### subsections within their parent ## section', () => {
    const sections = parseProjectMdSections(FIXTURE_FULL_PROJECT_MD);
    const commandsSection = sections.find((s) => s.header === '## Commands');

    expect(commandsSection).toBeDefined();
    expect(commandsSection!.content).toContain('### Build');
    expect(commandsSection!.content).toContain('### Test');
    expect(commandsSection!.content).toContain('### Verify');
  });

  it('should handle minimal content with preamble only', () => {
    const sections = parseProjectMdSections('Just some text\nwith no headers');

    expect(sections).toHaveLength(1);
    expect(sections[0].header).toBe('');
    expect(sections[0].content).toContain('Just some text');
  });

  it('should handle empty content', () => {
    const sections = parseProjectMdSections('');

    expect(sections).toHaveLength(1);
    expect(sections[0].header).toBe('');
    expect(sections[0].content).toBe('');
  });

  it('should handle content starting immediately with ##', () => {
    const sections = parseProjectMdSections('## First Section\nContent here');

    expect(sections).toHaveLength(1);
    expect(sections[0].header).toBe('## First Section');
    expect(sections[0].content).toBe('Content here');
  });

  it('should preserve content with custom user section', () => {
    const sections = parseProjectMdSections(FIXTURE_WITH_CUSTOM_SECTION);
    const customSection = sections.find((s) => s.header === '## My Custom Section');

    expect(customSection).toBeDefined();
    expect(customSection!.content).toContain('This is a section the user added manually.');
  });
});

// ============================================================================
// classifySection Tests
// ============================================================================

describe('classifySection', () => {
  it('should classify auto-update sections correctly', () => {
    expect(classifySection('## Project Overview')).toBe('auto-update');
    expect(classifySection('## Toolchain')).toBe('auto-update');
    expect(classifySection('## Commands')).toBe('auto-update');
    expect(classifySection('## Project Structure')).toBe('auto-update');
  });

  it('should classify static sections correctly', () => {
    expect(classifySection('## ðŸš¨ MANDATORY: Load CodeOps Rules Before Any Work')).toBe('static');
    expect(classifySection('## Cross-References')).toBe('static');
  });

  it('should classify preserve sections correctly', () => {
    expect(classifySection('## Coding Conventions')).toBe('preserve');
    expect(classifySection('## Git & Commit Conventions')).toBe('preserve');
    expect(classifySection('## Special Rules (Project-Specific)')).toBe('preserve');
  });

  it('should classify unknown sections as preserve', () => {
    expect(classifySection('## My Custom Section')).toBe('preserve');
    expect(classifySection('## Deployment Notes')).toBe('preserve');
  });

  it('should classify empty header (preamble) as preserve', () => {
    expect(classifySection('')).toBe('preserve');
  });

  it('should be case-insensitive', () => {
    expect(classifySection('## toolchain')).toBe('auto-update');
    expect(classifySection('## TOOLCHAIN')).toBe('auto-update');
    expect(classifySection('## cross-references')).toBe('static');
  });

  it('should handle headers with trailing whitespace', () => {
    expect(classifySection('## Toolchain  ')).toBe('auto-update');
  });
});

// ============================================================================
// generateFreshSection Tests
// ============================================================================

describe('generateFreshSection', () => {
  it('should find a matching section by header', () => {
    const freshSections = parseProjectMdSections(FIXTURE_FULL_PROJECT_MD);
    const result = generateFreshSection('## Toolchain', freshSections);

    expect(result).not.toBeNull();
    expect(result!.header).toBe('## Toolchain');
    expect(result!.content).toContain('TypeScript');
  });

  it('should return null for non-existent section', () => {
    const freshSections = parseProjectMdSections(FIXTURE_FULL_PROJECT_MD);
    const result = generateFreshSection('## Non Existent', freshSections);

    expect(result).toBeNull();
  });

  it('should match case-insensitively', () => {
    const freshSections = parseProjectMdSections(FIXTURE_FULL_PROJECT_MD);
    const result = generateFreshSection('## toolchain', freshSections);

    expect(result).not.toBeNull();
  });
});

// ============================================================================
// mergeAutoUpdateSection Tests
// ============================================================================

describe('mergeAutoUpdateSection', () => {
  it('should return existing content when identical to fresh', () => {
    const section: ParsedSection = {
      header: '## Toolchain',
      level: 2,
      content: '\n- **Language(s):** TypeScript\n',
    };
    const changes: MergeChange[] = [];

    const result = mergeAutoUpdateSection(section, section, changes);

    expect(changes).toHaveLength(0);
    expect(result).toContain('## Toolchain');
  });

  it('should replace with fresh content when different', () => {
    const existing: ParsedSection = {
      header: '## Toolchain',
      level: 2,
      content: '\n- **Language(s):** JavaScript\n',
    };
    const fresh: ParsedSection = {
      header: '## Toolchain',
      level: 2,
      content: '\n- **Language(s):** TypeScript\n',
    };
    const changes: MergeChange[] = [];

    const result = mergeAutoUpdateSection(existing, fresh, changes);

    expect(changes).toHaveLength(1);
    expect(changes[0].section).toBe('Toolchain');
    expect(result).toContain('TypeScript');
    expect(result).not.toContain('JavaScript');
  });

  it('should preserve user Description in Project Overview', () => {
    const existing: ParsedSection = {
      header: '## Project Overview',
      level: 2,
      content: '\n- **Name:** my-app\n- **Description:** My custom description\n- **Type:** library\n',
    };
    const fresh: ParsedSection = {
      header: '## Project Overview',
      level: 2,
      content: '\n- **Name:** my-app\n- **Description:** [TODO: Add project description]\n- **Type:** library\n',
    };
    const changes: MergeChange[] = [];

    const result = mergeAutoUpdateSection(existing, fresh, changes);

    expect(result).toContain('My custom description');
    expect(result).not.toContain('[TODO');
  });

  it('should NOT preserve [TODO] description', () => {
    const existing: ParsedSection = {
      header: '## Project Overview',
      level: 2,
      content: '\n- **Name:** old-name\n- **Description:** [TODO: Add project description]\n- **Type:** library\n',
    };
    const fresh: ParsedSection = {
      header: '## Project Overview',
      level: 2,
      content: '\n- **Name:** new-name\n- **Description:** [TODO: Add project description]\n- **Type:** library\n',
    };
    const changes: MergeChange[] = [];

    const result = mergeAutoUpdateSection(existing, fresh, changes);

    expect(result).toContain('new-name');
    expect(result).toContain('[TODO');
  });

  it('should detect name/type changes in Project Overview', () => {
    const existing: ParsedSection = {
      header: '## Project Overview',
      level: 2,
      content: '\n- **Name:** old-name\n- **Description:** My app\n- **Type:** api\n',
    };
    const fresh: ParsedSection = {
      header: '## Project Overview',
      level: 2,
      content: '\n- **Name:** new-name\n- **Description:** [TODO: Add project description]\n- **Type:** library\n',
    };
    const changes: MergeChange[] = [];

    const result = mergeAutoUpdateSection(existing, fresh, changes);

    expect(changes).toHaveLength(1);
    expect(changes[0].description).toContain('Updated name/type');
    // User description preserved
    expect(result).toContain('My app');
    // But name/type updated
    expect(result).toContain('new-name');
    expect(result).toContain('library');
  });
});

// ============================================================================
// formatChangeLog Tests
// ============================================================================

describe('formatChangeLog', () => {
  it('should format no-changes log', () => {
    const result = formatChangeLog([]);

    expect(result).toContain('âœ… Re-analyzed');
    expect(result).toContain('no changes detected');
    expect(result).toMatch(/\d{4}-\d{2}-\d{2}/); // Contains date
  });

  it('should format changes log with entries', () => {
    const changes: MergeChange[] = [
      { section: 'Toolchain', description: 'Updated with fresh scan data' },
      { section: 'Commands', description: 'Updated with fresh scan data' },
    ];

    const result = formatChangeLog(changes);

    expect(result).toContain('ðŸ”„ Updated');
    expect(result).toContain('incremental update');
    expect(result).toContain('Toolchain: Updated with fresh scan data');
    expect(result).toContain('Commands: Updated with fresh scan data');
    expect(result).toMatch(/\d{4}-\d{2}-\d{2}/);
  });

  it('should format single change', () => {
    const changes: MergeChange[] = [
      { section: 'Toolchain', description: 'Added ESLint' },
    ];

    const result = formatChangeLog(changes);

    expect(result).toContain('Changes detected:');
    expect(result).toContain('Toolchain: Added ESLint');
  });
});

// ============================================================================
// mergeProjectMd Tests (Integration)
// ============================================================================

describe('mergeProjectMd', () => {
  it('should produce output with change log when no changes', () => {
    const sections = parseProjectMdSections(FIXTURE_FULL_PROJECT_MD);
    const result = mergeProjectMd(sections, SAMPLE_ANALYSIS);

    expect(result).toContain('Re-analyzed');
    expect(result).toContain('# Generated Project Configuration');
  });

  it('should preserve user-customized sections verbatim', () => {
    const sections = parseProjectMdSections(FIXTURE_FULL_PROJECT_MD);
    const result = mergeProjectMd(sections, SAMPLE_ANALYSIS);

    // Coding Conventions was customized in fixture
    expect(result).toContain('- **Files:** kebab-case');
    expect(result).toContain('- **Components/Classes:** PascalCase');
  });

  it('should preserve custom user-added sections', () => {
    const sections = parseProjectMdSections(FIXTURE_WITH_CUSTOM_SECTION);
    const result = mergeProjectMd(sections, SAMPLE_ANALYSIS);

    expect(result).toContain('## My Custom Section');
    expect(result).toContain('This is a section the user added manually.');
  });

  it('should update auto-update sections when analysis changes', () => {
    const sections = parseProjectMdSections(FIXTURE_FULL_PROJECT_MD);
    const result = mergeProjectMd(sections, CHANGED_ANALYSIS);

    // Should contain updated frameworks
    expect(result).toContain('ESLint');
    expect(result).toContain('Jest');
    // Should contain change log entries
    expect(result).toContain('ðŸ”„ Updated');
    expect(result).toContain('Toolchain');
  });

  it('should preserve user description during merge', () => {
    const sections = parseProjectMdSections(FIXTURE_WITH_CUSTOM_DESCRIPTION);
    const result = mergeProjectMd(sections, SAMPLE_ANALYSIS);

    expect(result).toContain('A powerful MCP server for coding standards');
    expect(result).not.toContain('[TODO: Add project description]');
  });

  it('should preserve Special Rules section with user content', () => {
    const sections = parseProjectMdSections(FIXTURE_FULL_PROJECT_MD);
    const result = mergeProjectMd(sections, SAMPLE_ANALYSIS);

    expect(result).toContain('No special rules â€” this is an MCP server project.');
  });

  it('should add new sections from template that are missing in existing', () => {
    // Use minimal fixture that's missing most sections
    const sections = parseProjectMdSections(FIXTURE_MINIMAL);
    const result = mergeProjectMd(sections, SAMPLE_ANALYSIS);

    // Should append missing sections from fresh
    expect(result).toContain('## Commands');
    expect(result).toContain('## Cross-References');
    // Change log should note new sections
    expect(result).toContain('New section added from template');
  });

  it('should maintain existing section order', () => {
    const sections = parseProjectMdSections(FIXTURE_FULL_PROJECT_MD);
    const result = mergeProjectMd(sections, SAMPLE_ANALYSIS);

    const toolchainPos = result.indexOf('## Toolchain');
    const commandsPos = result.indexOf('## Commands');
    const codingPos = result.indexOf('## Coding Conventions');

    expect(toolchainPos).toBeLessThan(commandsPos);
    expect(commandsPos).toBeLessThan(codingPos);
  });
});

// ============================================================================
// readExistingProjectMd Tests (Integration with filesystem)
// ============================================================================

describe('readExistingProjectMd', () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await mkdtemp(join(tmpdir(), 'codeops-test-'));
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  it('should return null when no .clinerules directory exists', async () => {
    const result = await readExistingProjectMd(tempDir);
    expect(result).toBeNull();
  });

  it('should return null when .clinerules exists but no project.md', async () => {
    await mkdir(join(tempDir, '.clinerules'));
    const result = await readExistingProjectMd(tempDir);
    expect(result).toBeNull();
  });

  it('should return null for empty project.md', async () => {
    await mkdir(join(tempDir, '.clinerules'));
    await writeFile(join(tempDir, '.clinerules', 'project.md'), '');
    const result = await readExistingProjectMd(tempDir);
    expect(result).toBeNull();
  });

  it('should return null for whitespace-only project.md', async () => {
    await mkdir(join(tempDir, '.clinerules'));
    await writeFile(join(tempDir, '.clinerules', 'project.md'), '   \n  \n  ');
    const result = await readExistingProjectMd(tempDir);
    expect(result).toBeNull();
  });

  it('should return content when project.md exists with content', async () => {
    await mkdir(join(tempDir, '.clinerules'));
    await writeFile(join(tempDir, '.clinerules', 'project.md'), FIXTURE_FULL_PROJECT_MD);
    const result = await readExistingProjectMd(tempDir);
    expect(result).toBe(FIXTURE_FULL_PROJECT_MD);
  });
});

// ============================================================================
// analyzeProject Integration Tests (merge path)
// ============================================================================

describe('analyzeProject merge path', () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await mkdtemp(join(tmpdir(), 'codeops-merge-test-'));
    // Create a minimal Node.js project
    await writeFile(
      join(tempDir, 'package.json'),
      JSON.stringify({
        name: 'test-project',
        devDependencies: {
          typescript: '^5.0.0',
          vitest: '^2.0.0',
          '@modelcontextprotocol/sdk': '^1.0.0',
        },
      }),
    );
    await writeFile(join(tempDir, 'tsconfig.json'), '{}');
    await writeFile(join(tempDir, 'yarn.lock'), '');
    await mkdir(join(tempDir, 'src'));
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  it('should use fresh generation when no existing project.md', async () => {
    const result = await analyzeProject({ projectPath: tempDir });

    expect(result).toContain('# Generated Project Configuration');
    expect(result).toContain('## Toolchain');
    // Should NOT contain merge change log
    expect(result).not.toContain('Re-analyzed');
    expect(result).not.toContain('ðŸ”„ Updated');
  });

  it('should use merge path when existing project.md exists', async () => {
    // Create existing project.md
    await mkdir(join(tempDir, '.clinerules'));
    await writeFile(join(tempDir, '.clinerules', 'project.md'), FIXTURE_FULL_PROJECT_MD);

    const result = await analyzeProject({ projectPath: tempDir });

    // Should contain merge change log
    expect(result).toContain('analyze_project');
    // Should still contain main content
    expect(result).toContain('## Toolchain');
  });

  it('should preserve user customizations during merge', async () => {
    // Create existing project.md with custom description
    await mkdir(join(tempDir, '.clinerules'));
    await writeFile(
      join(tempDir, '.clinerules', 'project.md'),
      FIXTURE_WITH_CUSTOM_DESCRIPTION,
    );

    const result = await analyzeProject({ projectPath: tempDir });

    // User description should be preserved
    expect(result).toContain('A powerful MCP server for coding standards');
  });

  it('should preserve custom user sections during merge', async () => {
    await mkdir(join(tempDir, '.clinerules'));
    await writeFile(
      join(tempDir, '.clinerules', 'project.md'),
      FIXTURE_WITH_CUSTOM_SECTION,
    );

    const result = await analyzeProject({ projectPath: tempDir });

    expect(result).toContain('## My Custom Section');
    expect(result).toContain('This is a section the user added manually.');
  });
});

// ============================================================================
// Regression: Existing tests should still pass
// (These verify the fresh generation path is unchanged)
// ============================================================================

describe('analyzeProject fresh path (regression)', () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await mkdtemp(join(tmpdir(), 'codeops-fresh-test-'));
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  it('should return error for empty path', async () => {
    const result = await analyzeProject({ projectPath: '' });
    expect(result).toContain('**Error:**');
  });

  it('should return error for non-existent path', async () => {
    const result = await analyzeProject({ projectPath: '/tmp/non-existent-path-xyz-123' });
    expect(result).toContain('**Error:**');
  });

  it('should generate fresh project.md for new project', async () => {
    await writeFile(
      join(tempDir, 'package.json'),
      JSON.stringify({ name: 'fresh-test', devDependencies: { typescript: '^5.0.0' } }),
    );
    await writeFile(join(tempDir, 'tsconfig.json'), '{}');

    const result = await analyzeProject({ projectPath: tempDir });

    expect(result).toContain('# Generated Project Configuration');
    expect(result).toContain('## Toolchain');
    expect(result).toContain('TypeScript');
    expect(result).toContain('## Commands');
    expect(result).toContain('## Cross-References');
  });
});
